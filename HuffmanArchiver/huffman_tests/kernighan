<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Transitional//EN">
<HTML>
<HEAD>
   <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
   <meta name="Author" content="Alexander S. Derevjanko">
   <meta name="Generator" content="Far Editor">
   <meta name="Description" content="Data structures">
   <meta name="Owner" content="derev@insart.kharkov.ua">
   <meta name="Keywords" content="программирование, язык C">

<TITLE> Керниган и Ритчи </TITLE>
<!--                                                                   -->
<!-- (C) Source: http://kulichki.rambler.ru/moshkow/  -->
<!-- Owner: Alexander S. Derevjanko (web-design only)-->
<!-- ХГПУ. Каф.Информатики и интеллектуальной собственности, 2000. -->

</head>

<body background=../../iip_1.jpg>
<p>
<table cellpadding=10>
<tr><td><a href=../../index.htm>Каталог</a></td><td><a href=../index.htm>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=c_8.htm >Назад</a></td><td><a href=index.htm#index>Оглавление</a></td></tr>
</table>
</p>
<hr><h2>     9. Приложение А: справочное руководство по языку C</h2>
 <a name=91>
<h3>     9.1. Введение</h3>

<p>     Это руководство описывает язык C для компьютеров DEC PDP-11, HONEYWELL 6000, IBM SYSTEM/370 и INTERDATA 8/32. там, где есть расхождения, мы сосредотачиваемся на версии для PDP-11, стремясь в то же время указать детали, которые зависят от реализации. За малым исключением, эти расхождения непосредственно обусловлены основными свойствами используемого аппаратного оборудования; различные компиляторы обычно вполне совместимы.
<a name=10> 
<h2>    10. Лексические соглашения</h2>
<p>     Имеется шесть классов лексем: идентификаторы, ключевые слова, константы, строки, операции и другие разделители. Пробелы, табуляции , новые строки и комментарии (совместно, "пустые промежутки"), как описано ниже, игнорируются, за исключением тех случаев, когда они служат разделителями лексем. Необходим какой-то пустой промежуток для разделения идентификаторов, ключевых слов и констант, которые в противном случае сольются.
<p>     Если сделан разбор входного потока на лексемы вплоть до данного символа, то в качестве следующей лексемы берется самая длинная строка символов, которая еще может представлять собой лексему.

<a name=101> 
<h3>     10.1. Комментарии</h3>
<p>     Комментарий открывается символами /* и заканчивается
 символами /*. Комментарии не вкладываются друг в друга.
 
<a name=102>
<h3>     10.2. Идентификаторы (имена) </h3>
<p>     Идентификатор - это последовательность букв и цифр; первый символ должен быть буквой. Подчеркивание _ считается буквой. Буквы нижнего и верхнего регистров различаются. значащими являются не более, чем первые восемь символов, хотя можно использовать и больше. На внешние идентификаторы, которые используются различными ассемблерами и загрузчиками, накладывются более жесткие ограничения:
 <p><table align=center>
<tr><td>DEC PDP-11     </td><td>7 символов, </td><td>2 регистра</td></tr>
<tr><td>HONEYWELL 6000 </td><td>6 символов, </td><td>1 регистр</td></tr>
<tr><td>IBM 360/370    </td><td>7 символов, </td><td>1 регистр</td></tr>
<tr><td>INTERDATA 8/32 </td><td>8 символов, </td><td>2 регистра</td></tr>
</table></p>
<a name=103>      
<h3>      10.3. Ключевые слова</h3>
 
</td></tr>     Следующие идентификаторы зарезервированы для использования в качестве ключевых слов и не могут использоваться иным образом:
<p><table align=center>
<tr><td>auto</td><td>double</td><td>int</td><td>struct</td</tr>
<tr><td>break</td><td>else</td><td>long</td><td>switch</td></tr>
<tr><td>case</td><td>enum</td><td>register</td><td>typedef</td></tr>
<tr><td>char</td><td>extern</td><td>return</td><td>union</td></tr>
<tr><td>const</td><td>float</td><td>short</td><td>unsigned</td></tr>
<tr><td>continue</td><td>for</td><td>signed</td><td>void</td></tr>
<tr><td>default</td><td>goto</td><td>sizeof</td><td>volatile</td></tr>
<tr><td>do</td><td>if</td><td>static</td><td>while</td></tr>
</table></p>
 
<p> Ключевое слово entry в настоящее время не используется каким-либо компилятором; оно зарезервировано для использования в будущем. В некоторых реализациях резервируется также слова FORTRAN и ASM

<a name=104>
<h3>      10.4. Константы</h3>
<p> Имеется несколько видов констант, которые перечислены ниже. В пункте 10.6 резюмируются характеристики аппаратных средств, которые влияют на размеры.

<a name=1041>
<h4>     10.4.1. Целые константы</h4>
<p>     Целая константа, состоящая из последовательности цифр, считается восьмеричной, если она начинается с 0 (цифра нуль), и десятичной в противном случае. Цифры 8 и 9 имеют
 восьмеричные значения 10 и 11 соответственно. Последовательность цифр, которой предшествуют символы 0x (нуль, x-маленькое) или 0X (нуль X-большое), рассматривается как шестнадцатиричное целое. Шестнадцатиричные цифры включают буквы от а (маленькое) или A (большое) до f (маленькое) или F (большое) со значениями от 10 до 15. Десятичная константа, величина которой превышает наибольшее машинное целое со знаком, считается длинной; восьмеричная или шестнадцатиричная константа, которое превышает наибольшее машинное целое без знака, также считается длинной.

<a name=1042>
<h4>     10.4.2. Явные длинные константы</h4>
<p>Десятичная, восмеричная или шестнадцатиричная константа, за которой непосредственно следует l (эль-маленькое) или L (эль-большое), является длинной константой. Как обсуждается ниже, на некоторых машинах целые и длинные значения могут рассматриваться как идентичные.

<a name=1043>
<h4>     10.4.3. Символьные константы</h4>
<p>     Символьная константа - это символ, заключенный в одиночные кавычки, как, например, 'x'. Значением символьной константы является численное значение этого символа в машинном представлении набора символов.
<p>     Некоторые неграфические символы, одиночная кавычка ' и обратная косая черта \ могут быть представлены в соответствии со следующей таблицей условных последовательностей:
<p><table align=center> 
<tr><td>   новая строка                      </td><td>NL(LF)    </td><td>\n</td></tr>
<tr><td>   горизонтальная табуляция          </td><td>HT        </td><td>\t</td></tr>
<tr><td>   символ возврата на одну позицию   </td><td>BS        </td><td>\b</td></tr>
<tr><td>   возврат каретки                   </td><td>CR        </td><td>\r</td></tr>
<tr><td>   переход на новую страницу         </td><td>FF        </td><td>\f</td></tr>
<tr><td>   обратная косая черта              </td><td>\         </td><td>\\</td></tr>
<tr><td>   одиночная кавычка                 </td><td>'         </td><td>\'</td></tr>
<tr><td>   комбинация битов                  </td><td>DDD       </td><td>\DDD</td></tr>
</table></p> 
<p>     Условная последовательность \DDD состоит из обратной косой черты, за которой следуют 1,2 или 3 восьмеричных цифры, которые рассмативаются как задающие значение желаемого символа. Специальным случаем этой конструкции является последовательность \0 (за нулем не следует цифра), которая определяет символ NUL. если следующий за обратной косой чертой символ не совпадает с одним из указанных, то обратная косая черта игнорируется.

<a name=1044>
<h4>     10.4.4. Плавающие константы</h4>
<p>     Плавающая константа состоит из целой части, десятичной точки, дробной части, буквы e (маленькая) или E (большая) и целой экспоненты с необязательным знаком. Как целая, так и дробная часть являются последовательностью цифр. Либо целая, либо дробная часть (но не обе) может отсутствовать; либо десятичная точка, либо е (маленькая) и экспонента (но не то и другое одновременно) может отсутствовать. Каждая плавающая константа считается имеющей двойную точность.

<a name=105> 
<h3>     10.5. Строки</h3>
<p>     Строка - это последовательность символов, заключенная в двойные кавычки, как, например,"...". Строка имеет тип "массив массивов" и класс памяти static (см. Пункт 4 ниже). Строка инициализирована указанными в ней символами. Все строки, даже идентично записанные, считаются различными. Компилятор помещает в конец каждой строки нулевой байт \0, с тем чтобы просматривающая строку программа могла определить ее конец. Перед стоящим внутри строки символом двойной кавычки " должен быть поставлен символ обратной косой черты \; кроме того, могут использоваться те же условия последовательности, что и в символьных константах. И последнее, обратная косая черта \, за которой непосредственно следует
 символ новой строки, игнорируется.
     
<a name=106>
<h3>     10.6. Характеристики аппаратных средств</h3>
<p>     Следующая ниже таблица суммирует некоторые свойства аппаратного оборудования, которые меняются от машины к машине. Хотя они и влияют на переносимость программ, на практике они представляют маленькую проблему, чем это может казаться заранее.
<p align=center><b>           Таблица 1</b></p>
<p><table align=center border=1>
<tr><td></td><td>    ASCII        </td><td>ASCII</td><td>EBCDIC   </td><td>ASCII</td></tr>
<tr><td>  char   </td><td>ASCII 8 бит</td><td>ASCII 9 бит</td><td>EBCDIC 8 бит </td><td>ASCII 8 бит</td></tr>
<tr><td>  int    </td><td>16      </td><td>36             </td><td>32         </td><td>32</td></tr>
<tr><td>  short  </td><td>16      </td><td>36             </td><td>16         </td><td>16</td></tr>
<tr><td>  long   </td><td>32      </td><td>36             </td><td>32         </td><td>32</td></tr>
<tr><td>  float  </td><td>32      </td><td>36             </td><td>32         </td><td>32</td></tr>
<tr><td>  double </td><td>64      </td><td>72             </td><td>64         </td><td>64</td></tr>
<tr><td>  RANGE </td><td>-38/+38 </td><td>-38/+38         </td><td>-76/+76    </td><td>-76/+76</td></tr>
</table></p>

<a name=11>
<h2>     11. Синтаксическая нотация</h2>
 
<p>     В используемой в этом руководстве синтаксической нотации синтаксические категории выделяются курсивом (прим. перев.: в настоящее время синтаксические категории вместо курсивом выделяются подчеркиванием), а литерные слова и символы 
 жирным шрифтом. Альтернативные категории перечисляются на отдельных строчках. Необязательный символ, терминальный или нетерминальный, указывается индексом необ", так что <i>    { выражение<sub>необ</sub> }</i>
    
указывает на необязательное выражение, заключенное в фигурных скобках. Синтаксис суммируется в пункте 18.
<br><br> 
<a name=12>
<h2>    12. Что в имени тебе моем? </h2>
<p>    Язык C основывает интерпретацию идентификатора на двух признаках идентификатора: его классе памяти и его типе. Класс памяти определяет место и время хранения памяти, связанной с идентификатором; тип определяет смысл величин, находящихся в памяти, определенной под идентификатором.
<p>     Имеются четыре класса памяти: автоматическая, статическая, внешняя и регистровая. Автоматические переменные являются локальными для каждого вызова блока и исчезают при выходе из этого блока. Статические переменные являются локальными, но сохраняют свои значения для следующего входа в блок даже после того, как управление передается за пределы блока. Внешние переменные существуют и сохраняют свои значения в течение выполнения всей программы и могут использоваться для связи между функциями, в том числе и между независимо скомпилированными функциями. Регистровые переменные хранятся (ели это возможно) в быстрых регистрах машины; подобно автоматическим переменным они являются локальными для каждого блока и исчезают при выходе из этого блока.
<p>     В языке C предусмотрено несколько основных типов объектов.
<ul>
<li>     Объекты, написанные как символы (char), достаточно велики, чтобы хранить любой член из соответствующего данной реализации внутреннего набора символов, и если действительный символ из этого набора символов хранится в символьной переменной, то ее значение эквивалентно целому коду этого символа. В символьных переменных можно хранить и другие величины, но реализация будет машинно-зависимой.
<li>     Можно использовать до трех размеров целых, описываемых как short int, int и long int. Длинные целые занимают не меньше памяти, чем короткие, но в конкретной реализации может оказаться, что либо короткие целые, либо длинные целые, либо те и другие будут эквивалентны простым целым. "Простые" целые имеют естественный размер, предусматриваемый архитектурой используемой машины; другие размеры вводятся для удовлетворения специальных потребностей.
<li>     Целые без знака, описываемые как unsigned, подчиняются законам арифметики по модулю 2**n, где n - число битов в их представлении. (На PDP-11 длинные величины без знака не предусмотрены).
<li>     Плавающие одинарной точности (float) и плавающие двойной точности (double) в некоторых реализациях могут быть синонимами.
</ul>
<p>     Поскольку объекты упомянутых выше типов могут быть разумно интерпретированы как числа, эти типы будут называться арифметическими. типы char и int всех размеров совместно будут называться целочисленными. Типы float и double совместно будут называться плавающими типами.
<p>     Кроме основных арифметических типов существует концептуально бесконечный класс производных типов, которые образуются из основных типов следующим образом:
<ul>
<li>      массивы объектов большинства типов;
<li>      функции, которые возвращают объекты заданного типа;
<li>      указатели на объекты данного типа;
<li>      структуры, содержащие последовательность объектов различных типов;
<li>      объединения, способные содержать один из нескольких объектов различных типов.
</ul>
<p>     Вообще говоря, эти методы построения объектов могут применяться рекурсивно.
 
<a name=13>
<h2>     13. Объекты и L-значения</h2>
<p>     Объект является доступным обработке участком памяти; L-значение - это выражение, ссылающееся на объект. Очевидным примером выражения L-значения является идентификатор. Существуют операции, результатом которых являются L-значения; если, например, E - выражение указанного типа, то *E является выражением L-значения, ссылающимся на объект E. Название "L-значение" происходит от выражения присваивания e1=e2, в котором левая часть должна быть выражением L-значения. При последующем обсуждении каждой операции будет указываться, ожидает ли она операндов L-значения и выдает ли она L-значение. 

<a name=14>
<h2>14. Преобразования</h2>
 
<p>     Ряд операций может в зависимости от своих операндов вызывать преобразование значение операнда из одного типа в другой. В этом разделе объясняются результаты, которые следует ожидать от таких преобразований. В п. 14.6 подводятся итоги преобразований, требуемые большинством обычных операций; эти сведения дополняются необходимым образом при обсуждении каждой операции.
 
<a name=141>
<h3>     14.1. Символы и целые</h3>
<p>     Символ или короткое целое можно использовать всюду, где можно использовать целое. Во всех случаях значение преобразуется к целому. Преобразование более короткого целого к более длинному всегда сопровождается знаковым расширением; целые являются величинами со знаком. Осуществляется или нет знаковое расширение для символов, зависит от используемой машины, но гарантируется, что член стандартного набора символов неотрицателен. из всех машин, рассматриваемых в этом руководстве, только PDP-11 осуществляет знаковое расширение. область значений символьных переменных на PDP-11 меняется от -128 до 127; символы из набора ASCII имеют положительные значения. Символьная константа, заданная с помощью восьмеричной условной последовательности, подвергается знаковому расширению и может оказаться отрицательной; например, '\377' имеет значение -1.
<p>     Когда более длинное целое преобразуется в более короткое или в char, оно обрезается слева; лишние биты просто отбрасываются.
 
<a name=142>
<h3>     14.2. Типы float и double</h3>
<p>     Вся плавающая арифметика в C выполняется с двойной точностью каждый раз, когда объект типа float появляется в выражении, он удлиняется до double посредством добавления нулей в его дробную часть. когда объект типа double должен быть преобразован к типу float, например, при присваивании, перед усечением double округляется до длины float.

<a name=143>
<h3>     14.3. Плавающие и целочисленные величины</h3>
<p>     Преобразование плавающих значений к целочисленному типу имеет тенденцию быть до некоторой степени машинно-зависимым; в частности направление усечения отрицательных чисел меняется от машине к машине. Результат не определен, если значение не помещается в предоставляемое пространство.
<p>     Преобразование целочисленных значений в плавающие выполняется без осложнений. Может произойти некоторая потеря точности, если для результата не содержится достаточного количества битов.

<a name=144>
<h3>     14.4. Указатели и целые</h3>
<p>     Целое или длинное целое может быть прибавлено к указателю или вычтено из него; в этом случае первая величина преобразуется так, как указывается в разделе описания операции
 сложения.
<p>     Два указателя на объекты одинакового типа могут быть вычтены; в этом случае результат преобразуется к целому, как указывается в разделе описания операции вычитания.

<a name=145>
<h3>     14.5. Целое без знака</h3>
<p>     Всякий раз, когда целое без знака объединяется с простым целым, простое целое преобразуется в целое без знака и результат оказывается целым без знака. Значением является наименьшее целое без знака, соответствующее целому со знаком (по модулю 2**размер слова). В двоичном дополнительном представлении это преобразование является чисто умозрительным и не изменяет фактическую комбинацию битов.
<p>     Когда целое без знака преобразуется к типу long, значение результата совпадает со значением целого без знака. Таким образом, это преобразование сводится к добавлению нулей слева.

<a name=146>
<h3>     14.6. Арифметические преобразования</h3>
<p>     Подавляющее большинство операций вызывает преобразование и определяет типы результата аналогичным образом. Приводимая ниже схема в дальнейшем будет называться "обычными арифметическими преобразованиями".
<ul>
<li> Сначала любые операнды типа char или short преобразуются в int, а любые операнды типа float преобразуются в double.
<li> Затем, если какой-либо операнд имеет тип double, то другой преобразуется к типу double, и это будет типом результата.
<li> В противном случае, если какой-либо операнд имеет тип long, то другой операнд преобразуется к типу long, и это и будет типом результата.
<li> В противном случае, если какой-либо операнд имеет тип unsigned, то другой операнд преобразуется к типу unsigned, и это будет типом результата.
<li> В противном случае оба операнда будут иметь тип int, и это будет типом результата.
</ul> 

<a name=15>
<h2>     15. Выражения</h2>
<p>     Старшинство операций в выражениях совпадает с порядком следования основных подразделов настоящего раздела, начиная с самого высокого уровня старшинства. Так, например, выражениями, указываемыми в качестве операндов операции + (п.15.4), Являются выражения, определенные в п.п.15.1-15.3. Внутри каждого подраздела операции имеет одинаковое старшинство. В каждом подразделе для описываемых там операций указывается их ассоциативность слева или справа. Старшинство и ассоциативность всех операций в выражениях резюмируются в грамматической сводке в п.18.
<p>     В противном случае порядок вычислений выражений не определен. В частности, компилятор считает себя в праве вычислять подвыражения в том порядке, который он находит наиболее эффективным, даже если эти подвыражения приводят к побочным эффектам. Порядок, в котором происходят побочные эффекты, не специфицируется. Выражения, включающие коммутативные и ассоциативные операции ( *,+,&,!,^ ), могут быть переупорядочены произвольным образом даже при наличии круглых скобок; чтобы вынудить определенный порядок вычислений, в этом случае необходимо использовать явные промежуточные переменные.
<p>     При вычислении выражений обработка переполнения и проверка при делении являются машинно-зависимыми. Все существующие реализации языка C игнорируют переполнение целых; обработка ситуаций при делении на 0 и при всех особых случаях с плавающими числами меняется от машины к машине и обычно выполняется с помощью библиотечной функции.

<a name=151>
<h3>     15.1. Первичные выражения</h3>
<p>     Первичные выражения, включающие ., -&gt;, индексацию и обращения к функциям, группируются слева направо.
 
   Первичное выражение:
   идентификатор
   константа
   строка
   (выражение)
   первичное-выражение  [выражение]
   первичное-выражение  (список-выражений   нео
   первичное-L-значение . Идентификатор
   первичное-выражение -&gt; идентификатор
   список-выражений:
   выражение
   список-выражений, выражение
      
<p> Идентификатор является первичным выражением при условии, что он описан подходящим образом, как это обсуждается ниже. тип идентификатора определяется его описанием. Если, однако, типом идентификатора является "массив ...", то значением выражения, состоящего из этого идентификатора , является указатель на первый объект в этом массиве, а типом выражения будет "указатель на ...". Более того, идентификатор массива не является выражением L-значения. подобным образом идентификатор, который описан как "функция, возвращающая ...", за исключением того случая, когда он используется в позиции имени функции при обращении, преобразуется в "указатель на функцию, которая возвращает ...".
<p>     Константа является первичным выражением. В зависимости от ее формы типом константы может быть int, long или double.
<p>     Строка является первичным выражением. Исходным ее типом является "массив символов"; но следуя тем же самым правилам, которые приведены выше для идентификаторов, он модифицируется в "указатель на символы", и результатом является указатель на первый символ строки. (имеется исключение в некоторых инициализаторах; см. п. 16.6.)
<p>     Выражение в круглых скобках является первичным выражением, тип и значение которого идентичны типу и значению этого выражения без скобок. Наличие круглых скобок не влияет на то, является ли выражение L-значением или нет.
<p>     Первичное выражение, за которым следует выражение в квадратных скобках, является первичным выражением. Интуитивно ясно, что это выражение с индексом. Обычно первичное выражение имеет тип "указатель на ...", индексное выражение имеет тип int, а типом результата является "...". Выражение e1[e2] по определению идентично выражению * ((e1) + (e2)). Все, что необходимо для понимания этой записи, содержится в этом разделе; вопросы, связанные с понятием идентификаторов и операций * и + рассматриваются в п.п. 15.1, 15.2 И 15.4
 соответственно; выводы суммируются ниже в п. 22.3.
<p>     Обращение к функции является первичным выражением, за которым следует заключенный в круглые скобки возможно пустой список выражений, разделенных запятыми, которые и представляют собой фактические аргументы функции. Первичное выражение должно быть типа "функция, возвращающая ...", а результат обращения к функции имеет тип "...". Как указывается ниже, ранее не встречавшийся идентификатор, за которым непосредственно следует левая круглая скобка, считается описанным по контексту, как представляющий функцию, возвращающую целое; следовательно чаще всего встречающийся случай функции, возвращающей целое значение, не нуждается в описании.
<p>     Перед обращением любые фактические аргументы типа float преобразуются к типу double, любые аргументы типа char или short преобразуются к типу int, и, как обычно, имена массивов преобразуются в указатели. Никакие другие преобразования не выполняются автоматически; в частности, не сравнивает типы фактических аргументов с типами формальных аргументов. Если преобразование необходимо, используйте явный перевод типа (cast); см. п.п. 15.2, 16.7.
<p>     При подготовке к вызову функции делается копия каждого фактического параметра; таким образом, все передачи аргументов в языке C осуществляются строго по значению. функция может изменять значения своих формальных параметров, но эти изменения не влияют на значения фактических параметров. С другой стороны имеется возможность передавать указатель при таком условии, что функция может изменять значение объекта, на который этот указатель указывает. Порядок вычисления аргументов в языке не определен; обратите внимание на то, что различные компиляторы вычисляют по разному.
<p>     Допускаются рекурсивные обращения к любой функции.
<p>     Первичное выражение, за которым следует точка и идентификатор, является выражением. Первое выражение должно быть L-значением, именующим структуру или объединение, а идентификатор должен быть именем члена структуры или объединения. Результатом является L-значение, ссылающееся на поименованный член структуры или объединения.
<p>     Первичное выражение, за которым следует стрелка (составленная из знаков - и &gt;) и идентификатор, является выражением. первое выражение должно быть указателем на структуру или объединение, а идентификатор должен именовать член этой структуры или объединения. Результатом является L-значение, ссылающееся на поименованный член структуры или объединения, на который указывает указательное выражение.
<p>     Следовательно, выражение e1-&gt;mos является тем же самым, что и выражение (*e1).mos. Структуры и объединения рассматриваются в п. 16.5. Приведенные здесь правила использования структур и объединений не навязываются строго, для того чтобы иметь возможность обойти механизм типов. См. п. 22.1.
     
<a name=152>
<h3>     15.2. Унарные операции</h3>
<p>     Выражение с унарными операциями группируется справа налево.
  Унарное-выражение:
       *  выражение
       &  L-значение
       -  выражение
       !  Выражение
       ~ выражение
       ++ L-значение
       -- L-значение
       L-значение ++
       L-значение --
       (имя-типа) выражение
       sizeof выражение
       sizeof имя-типа
 
<p>     Унарная операция * означает косвенную адресацию: выражение должно быть указателем, а результатом является L-значение, ссылающееся на тот объект, на который указывает выражение. Если типом выражения является "указатель на...", то типом результата будет "...".
<p>     Результатом унарной операции & является указатель на объект, к которому ссылается L-значение. Если L-значение имеет тип "...", то типом результата будет "указатель на ...".
<p>     Результатом унарной операции - (минус) является ее операнд, взятый с противоположным знаком. Для величины типа unsigned результат получается вычитанием ее значения из 2**n (два в степени n), где n-число битов в int. Унарной операции + (плюс) не существует.
<p>     Результатом операции логического отрицания ! Является 1, если значение ее операнда равно 0, и 0, если значение ее операнда отлично от нуля. Результат имеет тип int. Эта операция применима к любому арифметическому типу или указате-
 лям.
<p>     Операция ~ дает обратный код, или дополнение до единицы, своего операнда. Выполняются обычные арифметические преобразования. Операнд должен быть целочисленного типа.
<p>     Объект, на который ссылается операнд L-значения префиксной операции ++, увеличивается. значением является новое значение операнда, но это не L-значение. Выражение ++х эквивалентно х+=1. Информацию о преобразованиях смотри в разборе операции сложения (п. 15.4) и операции присваивания (п. 15.14).
<p>     Префиксная операция -- аналогична префиксной операции ++, но приводит к уменьшению своего операнда L-значения.
<p>     При применении постфиксной операции ++ к L-значению результатом является значение объекта, на который ссылается L-значение. После того, как результат принят к сведению, объект увеличивается точно таким же образом, как и в случае
 префиксной операции ++. Результат имеет тот же тип, что и выражение L-значения.
<p>     При применении постфиксной операции -- к L-значению результатом является значение объекта, на который ссылается L-значение. После того, как результат принят к сведению, объект уменьшается точно таким же образом, как и в случае префиксной операции --. Результат имеет тот же тип, что и выражение L-значения.
<p>     Заключенное в круглые скобки имя типа данных, стоящее перед выражением , вызывает преобразование значения этого выражения к указанному типу. Эта конструкция называется перевод (cast). Имена типов описываются в п. 16.7.
<p>     Операция sizeof выдает размер своего операнда в байтах. (Понятие байт в языке не определено, разве только как значение операции sizeof. Однако во всех существующих реализациях байтом является пространство, необходимое для хранения объекта типа char). При применении к массиву результатом является полное число байтов в массиве. Размер определяется из описаний объектов в выражении. Это выражение семантически является целой константой и может быть использовано в любом месте, где требуется константа. Основное применение эта операция находит при связях с процедурами, подобным распределителям памяти, и в системах ввода- вывода.
<p>     Операция sizeof может быть также применена и к заключенному в круглые скобки имени типа. В этом случае она выдает размер в байтах объекта указанного типа.
<p>     Конструкция sizeof (тип) рассматривается как целое, так что выражение sizeof (тип) - 2 эквивалентно выражению (sizeof (тип)) - 2.

<a name=153>
<h3>     15.3. Мультипликативные операции</h3>
<p>     Мультипликативные операции *, /, и % группируются слева направо. Выполняются обычные арифметические преобразования.
   Мультипликативное-выражение:
   выражение * выражение
   выражение / выражение
   выражение % выражение
<p>     Бинарная операция * означает умножение. Операция * ассоциативна, и выражения с несколькими умножениями на одном и том же уровне могут быть перегруппированы компилятором.
<p>     Бинарная операция / означает деление. При делении положительных целых осуществляется усечение по направлению к нулю, но если один из операндов отрицателен, то форма усечения зависит от используемой машины. На всех машинах, охватываемых настоящим руководством, остаток имеет тот же знак , что и делимое. Всегда справедливо, что (a/b)*b+a%b равно a (если b не равно 0).
<p>     Бинарная операция % выдает остаток от деления первого выражения на второе. Выполняются обычные арифметические преобразования. Операнды не должны быть типа float.

<a name=154>
<h3>     15.4. Аддитивные операции</h3>
<p>     Аддитивные операции + и - группируются слева направо. Выполняются обычные арифметические преобразования. Для каждой операции имеются некоторые дополнительные возможности, связанные с типами операндов.
     
  Аддитивное-выражение:
  выражение + выражение
  выражение - выражение
 
<p> Результатом операции + является сумма операндов. Можно складывать указатель на объект в массиве и значение любого целочисленного типа. во всех случаях последнее преобразуется в адресное смещение посредством умножения его на длину объекта, на который указывает этот указатель. Результатом является указатель того же самого типа, что и исходный указатель, который указывает на другой объект в том же массиве, смещенный соответствующим образом относительно первоначального объекта. Таким образом, если p является указателем объекта в массиве, то выражение p+1 является указателем на следующий объект в этом массиве.
<p>     Никакие другие комбинации типов для указателей не разрешаются.
<p>     Операция + ассоциативна, и выражение с несколькими сложениями на том же самом уровне могут быть переупорядочены компилятором.
<p>     Результатом операции - является разность операндов. Выполняются обычные арифметические преобразования. Кроме того, из указателя может быть вычтено значение любого целочисленного типа, причем, проводятся те же самые преобразования, что и при операции сложения.
<p>     Если вычитаются два указателя на объекты одинакового типа, то результат преобразуется (делением на длину объекта) к типу int, представляя собой число объектов, разделяющих указываемые объекты. Если эти указатели не на объекты из одного и того же массива, то такое преобразование, вообще говоря, даст неожиданные результаты, потому что даже указатели на объекты одинакового типа не обязаны отличаться на величину, кратную длине объекта.

<a name=155>
<h3>     15.5. Операции сдвига</h3>
<p>     Операции сдвига &lt;&lt; и &gt;&gt; группируются слева направо. Для обеих операций проводятся обычные арифметические преобразования их операндов, каждый из которых должен быть целочисленного типа. Затем правый операнд преобразуется к типу int; результат имеет тип левого операнда. Результат не определен, если правый операнд отрицателен или больше или равен, чем длина объекта в битах.
<br><br><i>   Выражение-сдвига:<br>
   выражение &lt;&lt; выражение<br>
   выражение &gt;&gt; выражение</i>
 
<p> Значением выражения e1&lt;&lt;e2 является e1 (интерпретируемое как комбинация битов), сдвинутое влево на e2 битов; освобождающиеся биты заполняются нулем. значением выражения e1&gt;&gt;e2 является e1, сдвинутое вправо на e2 битовых позиций. Если e1 имеет тип unsigned, то сдвиг вправо гарантированно будет логическим (заполнение нулем); в противном случае сдвиг может быть (и так и есть на PDP-11) арифметическим (освобождающиеся биты заполняются копией знакового бита).
     
<a name=156>
<h3>     15.6. Операции отношения</h3>
<p>     Операции отношения группируются слева направо, но этот факт не очень полезен; выражение a&lt;b&lt;c не означает того, что оно казалось бы должно означать.<br>
<br><i>
   Выражение-отношения:<br>
   выражение &lt; выражение<br>
   выражение &gt; выражение<br>
   выражение &lt;= выражение<br>
   выражение &gt;= выражение</i>
 
<p> Операции &lt; (меньше), &gt; (больше), &lt;= (меньше или равно) и &gt;= (больше или равно) все дают 0, если указанное отношение ложно, и 1, если оно истинно. Результат имеет тип int. Выполняются обычные арифметические преобразования. Могут сравниваться два указателя; результат зависит от относительного расположения указываемых объектов в адресном пространстве. Сравнение указателей переносимо только в том случае, если указатели указывают на объекты из одного и того же массива.

<a name=157>
<h3>     15.7. Операции равенства</h3>
<i>     Выражение-равенства:<br>
  выражение == выражение<br>
  выражение != выражение</i>
 
<p> Операции == (равно) и != (не равно) в точности аналогичны операциям отношения, за исключением того, что они имеют более низкий уровень старшинства. (Поэтому значение выражения a&lt;b==c&lt;d равно 1 всякий раз, когда выражение a&lt;b и c&lt;d имеют одинаковое значение истинности).
<p>     Указатель можно сравнивать с целым, но результат будет машинно- независимым только в том случае, если целым является константа 0. Гарантируется, что указатель, которому присвоено значение 0, не указывает ни на какой объект и на самом деле оказывается равным 0; общепринято считать такой указатель нулем.

<a name=158>
<h3>     15.8. Побитовая операция 'и'</h3>
<i>
     Выражение-и:<br>
  выражение & выражение</i>
 
<p> Операция & является ассоциативной, и включающие & выражения могут быть переупорядочены. Выполняются обычные арифметические преобразования; результатом является побитовая функция 'и' операндов. Эта операция применима только к операндам целочисленного типа.

<a name=159>
<h3>     15.9. Побитовая операция исключающего 'или'</h3>
<i>     Выражение-исключающего-или:<br>
   выражение ^ выражение</i><br>
 
<p> Операция ^ является ассоциативной, и включающие ^ выражения могут быть переупорядочены. выполняются обычные арифметические преобразования; результатом является побитовая функция исключающего 'или' операндов. Операция применима только к операндам целочисленного типа.
     
<a name=1510>
<h3>     15.10. Побитовая операция включающего 'или'</h3>
<i>     Выражение-включающего-или:<br>
   выражение | Выражение</i>
 
<p> Операция | Является ассоциативной, и содержащие | выражения могут быть переупорядочены. выполняются обычные арифметические преобразования; результатом является побитовая функция включающего 'или' операндов. Операция применима только к операндам целочисленного типа.

<a name=1511>
<h3>     15.11. Логическая операция 'и'</h3>
<i>     Выражение-логического-и:<br>
   выражение && выражение</i>
 
<p> Операция && группируется слева направо. Она возвращает 1, если оба ее операнда отличны от нуля, и 0 в противном случае. В отличие от & операция && гарантирует вычисление слева направо; более того, если первый операнд равен 0, то значение второго операнда вообще не вычисляется.
<p>     Операнды не обязаны быть одинакового типа, но каждый из них должен быть либо одного из основных типов, либо указателем. результат всегда имеет тип int.

<a name=1512>
<h3>     15.12. Операция логического 'или'</h3>
<i>     Выражение-логического-или:<br>
  выражение || выражение</i>
 
<p> Операция || группируется слева направо. Она возвращает 1, если один из операндов отличен от нуля, и 0 в противном случае. В отличие от операции | операция || гарантирует вычисление слева направо; более того, если первый операнд отличен от нуля, то значение второго операнда вообще не вычисляется.
<p>     Операнды не обязаны быть одинакового типа, но каждый из них должен быть либо одного из основных типов, либо указателем. Результат всегда имеет тип int.

<a name=1513>
<h3>     15.13. Условная операция</h3>
<i>     Условное-выражение:<br>
  выражение ? выражение : выражение</i>
 
<p> Условные выражения группируются слева направо. Вычисляется значение первого выражения, и если оно отлично от нуля, то результатом будет значение второго выражения; в противном случае результатом будет значение третьего выражения. Если это возможно, проводятся обычные арифметические преобразования, с тем, чтобы привести второе и третье выражения к общему типу; в противном случае, если оба выражения являются указателями одинакового типа, то результат имеет тот же тип; в противном случае одно выражение должно быть указателем, а другое - константой 0, и результат будет иметь тип указателя. Вычисляется только одно из второго и третьего выражений.
     
<a name=1514>
<h3>     15.14. Операция присваивания</h3>
<p>     Имеется ряд операций присваивания, каждая из которых группируется слева направо. Все операции требуют в качестве своего левого операнда L-значение, а типом выражения присваивания является тип его левого операнда. Значением выражения присваивания является значение, хранимое в левом операнде после того, как присваивание уже будет произведено. Две части составной операции присваивания являются отдельными лексемами.
<br><br><i>
     Выражение-присваивания:<br>
   L-значение = выражение<br>
   L-значение += выражение<br>
   L-значение -= выражение<br>
   L-значение *= выражение<br>
   L-значение /= выражение<br>
   L-значение %= выражение<br>
   L-значение &gt;&gt;= выражение<br>
   L-значение &lt;&lt;= выражение<br>
   L-значение &= выражение<br>
   L-значение ^= выражение<br>
   L-значение |= выражение</i>
 
<p>     Когда производится простое присваивание 'c=', значение выражения заменяет значение объекта, на которое ссылается L-значение. Если оба операнда имеют арифметический тип, то перед присваиванием правый операнд преобразуется к типу левого операнда.
<p>     О свойствах выражения вида e1 оп = e2, где оп - одна из перечисленных выше операций, можно сделать вывод, если учесть, что оно эквивалентно выражению e1 = e1 оп (e2); однако выражение e1 вычисляется только один раз. В случае операций += и -= левый операнд может быть указателем, причем при этом (целочисленный) правый операнд преобразуется таким образом, как объяснено в п. 15.4; все правые операнды и все отличные от указателей левые операнды должны иметь арифметический тип.
<p>     Используемые в настоящее время компиляторы допускают присваивание указателя целому, целого указателю и указателя указателю другого типа. такое присваивание является чистым копированием без каких-либо преобразований. Такое употребление операций присваивания является непереносимым и может приводить к указателям, которые при использовании вызывают ошибки адресации. Тем не менее гарантируется, что присваивание указателю константы 0 дает нулевой указатель, который можно отличать от указателя на любой объект.

<a name=1515>
<h3>     15.15. Операция запятая</h3>
<i>     Выражение-с-запятой:<br>
   выражение , выражение</i>

<p> Пара выражений, разделенных запятой, вычисляется слева направо и значение левого выражения отбрасывается. Типом и значением результата является тип и значение правого операнда. Эта операция группируется слева направо. В контексте, где запятая имеет специальное значение, как, например, в списке фактических аргументов функций (п. 15.1) Или в списках инициализаторов (п. 16.6), Операция запятая, описываемая в этом разделе, может появляться только в круглых скобках; например, функция
<pre> 
   f(a,(t=3,t+2),c)
</pre> 
имеет три аргумента, второй из которых имеет значение 5.
<a name=16>
<h2>     16. Описания</h2>
<p>     Описания используются для указания интерпретации, которую язык C будет давать каждому идентификатору; они не обязательно резервируют память, соответствующую идентификатору. Описания имеют форму
<br><br><i>  Описание:<br>
  спецификаторы-описания список-описателей<sub>необ</sub>;</i>
 
<p> Описатели в списке описателей содержат описываемые идентификаторы. Спецификаторы описания представляют собой последовательность спецификаторов типа и спецификаторов класса памяти.<br>
<br><i> 
 Спецификаторы-описания:<br>
   спецификатор-типа спецификаторы-описания<sub>необ</sub><br>
   спецификатор-класса-памяти спецификатор-описания<sub>необ</sub><br>
</i><br> 
список должен быть самосогласованным в смысле, описываемом ниже.

<a name=161>
<h3>     16.1. Спецификаторы класса памяти</h3>
<p>     Ниже перечисляются спецификаторы класса памяти:
<br><br><i>
  Спецификатор-класса-памяти:<br>
       auto<br>
       static<br>
       extern<br>
       register<br>
       typedef</i>
 
<p>     Спецификатор typedef не реализует памяти и называется "спецификатором класса памяти" только по синтаксическим соображениям; это обсуждается в п. 16.8. Смысл различных классов памяти был обсужден в п. 12.
<p>     Описания auto, static и register служат также в качестве определений в том смысле, что они вызывают резервирование нужного количества памяти. В случае extern должно присутствовать внешнее определение (п. 18) Указываемых идентификаторов где-то вне функции, в которой они описаны.
     
<p>     Описание register лучше всего представлять себе как описание auto вместе с намеком компилятору, что описанные таким образом переменные будут часто использоваться. Эффективны только несколько первых таких описаний. Кроме того, в регистрах могут храниться только переменные определенных типов; на PDP-11 это int, char или указатель. Существует и другое ограничение на использование регистровых переменных: к ним нельзя применять операцию взятия адреса &. При разумном использовании регистровых описаний можно ожидать получения меньших по размеру и более быстрых программ, но улучшение в будущем генерирования кодов может сделать их ненужными.
<p>     Описание может содержать не более одного спецификатора класса памяти. Если описание не содержит спецификатора класса памяти, то считается, что он имеет значение auto, если описание находится внутри некоторой функции, и extern в противном случае. исключение: функции никогда не бывает автоматическими.

<a name=162>
<h3>     16.2. Спецификаторы типа</h3>
<p>     Ниже перечисляются спецификаторы типа.<br>
<br><i> 
   Спецификатор-типа:<br>
   char<br>
   short<br>
   int<br>
   long<br>
   unsigned<br>
   float<br>
   double<br>
   спецификатор-структуры-или-объединения<br>
   определяющее-тип-имя</i>
 
<p>     Слова long, short и unsigned можно рассматривать как прилагательные; допустимы следующие комбинации:
<br><br><i>
   short int<br>
   long int
   unsigned int<br>
   long float
</i> 
<p> Последняя комбинация означает то же, что и double. В остальном описание может содержать не более одного спецификатора типа. Если описание не содержит спецификатора типа, то считается, что он имеет значение int.
<p>     Спецификаторы структур и объединений обсуждаются в п. 16.5; Описания с определяющими тип именами typedef обсуждаются в п. 16.8.
     
<a name=163>
<h3>     16.3. Описатели</h3>
<p>     Входящий в описание список описателей представляет собой последовательность разделенных запятыми описателей, каждый из которых может иметь инициализатор.
<br><br><i>
   Список-описателей:<br>
  инициализируемый-описатель<br>
  инициализируемый-описатель, список-описателей<br>
   инициализируемый-описатель:<br>
  описатель-инициализатор<sub>необ</sub></i>
 
<p> Инициализаторы описываются в п. 16.6. Спецификаторы и описания указывают тип и класс памяти объектов, на которые ссылаются описатели. Описатели имеют следующий синтаксис:
<br><br><i> 
  описатель:<br>
  идентификатор<br>
  ( описатель )<br>
  * описатель<br>
  описатель ()<br>
  описатель [константное-выражение<sub>необ</sub>]</i>
 
<p> Группирование такое же, как и в выражениях.

<a name=164>
<h3>     16.4. Смысл описателей</h3>
<p>     Каждый описатель рассматривается как утверждение того, что когда конструкция той же самой формы, что и описатель, появляется в выражении, то она выдает объект указанного типа и указанного класса памяти. Каждый описатель содержит ровно один идентификатор; это именно тот идентификатор, который и описывается.
<p>     Если в качестве описателя появляется просто идентификатор, то он имеет тип, указываемый в специфицирующем заголовке описания.
<p>     Описатель в круглых скобках идентичен описателю без круглых скобок, но круглые скобки могут изменять связи в составных описателях. Примеры смотри ниже.
<p>     Представим себе описание
<pre> 
    t     DI
</pre> 
где t - спецификатор типа (подобный int и т.д.), а DI - описатель. Предположим, что это описание приводит к тому, что соответствующий идентификатор имеет тип "...t", где "..." пусто, если DI просто отдельный идентификатор (так что тип x в "int x" просто int). Тогда , если DI имеет форму 
<pre>
     *d
</pre> 
то содержащийся идентификатор будет иметь тип "... Указатель на t".
<p>     Если DI имеет форму
<pre> 
     d()
</pre> 
то содержащийся идентификатор имеет тип "... Функция, возвращающая t".
<p>     Если DI имеет форму
<pre> 
  d[константное-выражение]
</pre> 
или
<pre> 
  d[ ]
</pre> 
то содержащийся идентификатор имеет тип "...массив t". В первом случае константным выражением является выражение, значение которого можно определить во время компиляции и которое имеет тип int. (Точное определение константного выражения дано в п. 23). Когда несколько спецификаций вида "массив из" оказываются примыкающими, то создается многомерный массив; константное выражение, задающее границы массивов, может отсутствовать только у первого члена этой последовательности. Такое опускание полезно, когда массив является внешним и его фактическое определение, которое выделяет память, приводится в другом месте. Первое константное выражение может быть опущено также тогда, когда за описателем следует инициализация. В этом случае размер определяется по числу приведенных инициализируемых элементов.
<p>     Массив может быть образован из элементов одного из основных типов, из указателей, из структур или объединений или из других массивов (чтобы образовать многомерный массив).
<p>     Не все возможности, которые разрешены с точки зрения указанного выше синтаксиса, фактически допустимы. Имеются следующие ограничения: функции не могут возвращать массивы, структуры, объединения или функции, хотя они могут возвращать указатели на такие вещи; не существует массивов функций, хотя могут быть массивы указателей на функции. Аналогично, структуры или объединения не могут содержать функцию, но они могут содержать указатель на функцию.
<p>     В качестве примера рассмотрим описание
<pre> 
  int i, *ip, f(), *fip(), (*pfi)();
</pre> 
 в котором описывается целое i, указатель ip на целое, функция f, возвращающая целое, функция fip, возвращающая указатель на целое, и указатель pfi на функцию, которая возвращает целое. Особенно полезно сравнить два последних описателя. Связь в *fip() можно представить в виде *(fip()), так что описанием предполагается, а такой же конструкцией в выражении требуется обращение к функции fip и последующее использование косвенной адресации для выдачи с помощью полученного результата (указателя) целого. В описателе (*pfi)() дополнительные скобки необходимы, поскольку они точно так же, как и в выражении, указывают, что косвенная адресация через указатель на функцию выдает функцию, которая затем вызывается; эта вызванная функция возвращает целое.
<p>     В качестве другого примера приведем описание
<pre> 
    float fa[17], *afp[17];
</pre> 
в котором описывается массив чисел типа float и массив указателей на числа типа float. Наконец,
<pre> 
   static int x3d[3][5][7];
</pre> 
описывает статический трехмерный массив целых размером 3*5*7. более подробно, x3d является массивом из трех элементов; каждый элемент является массивом пяти массивов; каждый последний массив является массивом из семи целых. Каждое из выражений x3d, x3d[i], x3d[i][j] и x3d[i][j][k] может разумным образом появляться в выражениях. Первые три имеют тип "массив", последнее имеет тип int.

<a name=165>
<h3>     16.5. Описание структур и объединений</h3>
<p>     Структура - это объект, состоящий из последовательности именованных членов. каждый член может быть произвольного типа. Объединение - это объект, который в данный момент может содержать любой из нескольких членов. Спецификаторы и объединения имеют одинаковую форму.
<br><br><i>
 Спецификатор-структуры-или-объединения:<br>

 структура-или-объединение { список-описаний-структуры }<br>
 
 идентификатор    структуры-или-объединения<br>
 { список-описаний-структуры }<br>
 идентификатор структуры-или-объединения<br><br>
 
 Структура-или-объединение:<br>
 
    struct<br>
    union<br></i>
 
<p> Список-описаний-структуры является последовательностью описаний членов структуры или объединения:
<br><br><i> 
  Список-описаний-структуры:<br>
 описание-структуры<br>
 описание-структуры список-описаний-структуры<br>
  описание-структуры:<br>
 спецификатор-типа список-описателей-структуры<br>
  список-описателей-структуры:<br>
 описатель-структуры<br>
 описатель-структуры, список-описателей-структуры</i>
 
<p> В обычном случае описатель структуры является просто описателем члена структуры или объединения. Член структуры может также состоять из специфицированного числа битов. Такой член называется также полем; его длина отделяется от имени поля двоеточием.
<br><br><i>
    Описатель-структуры:<br>
   описатель<br>
   описатель: константное выражение<br>
   : константное выражение</i>
 
<p> Внутри структуры описанные в ней объекты имеют адреса, которые увеличиваются в соответствии с чтением их описаний слева направо. Каждый член структуры, который не является полем, начинается с адресной границы, соответствующей его типу; следовательно в структуре могут оказаться неименованные дыры. Члены, являющиеся полями, помещаются в машинные целые; они не перекрывают границы слова. Поле, которое не умещается в оставшемся в данном слове пространстве, помещается в следующее слово. Поля выделяются справа налево на PDP-11 и слева направо на других машинах.
<p>     Описатель структуры, который не содержит описателя, а только двоеточие и ширину, указывает неименованное поле, полезное для заполнения свободного пространства с целью соответствия задаваемых извне схемам. Специальный случай неименованного поля с шириной 0 используется для указания о выравнивании следующего поля на границу слова. При этом предполагается, что "следующее поле" действительно является полем, а не обычным членом структуры, поскольку в последнем случае выравнивание осуществляется автоматически.
<p>     Сам язык не накладывает ограничений на типы объектов, описанных как поля, но от реализаций не требуется обеспечивать что-либо отличное от целых полей. Более того, даже поля типа int могут рассматриваться как не имеющие знака. На PDP-11 поля не имеют знака и могут принимать только целые значения. Во всех реализациях отсутствуют массивы полей и к полям не применима операция взятия адреса &, так что не существует и указателей на поля.
<p>     Объединение можно представить себе как структуру, все члены которой начинаются со смещения 0 и размер которой достаточен, чтобы содержать любой из ее членов. В каждый момент объединение может содержать не более одного из своих членов.
<p>     Спецификатор структуры или объединения во второй форме, т.е. Один из
<pre> 
 struct идентификатор { список-описаний-структуры }
 
 union идентификатор { список-описаний-структуры }
</pre> 
 описывает идентификатор в качестве ярлыка структуры (или ярлыка объединения) структуры, специфицированной этим списком. Последующее описание может затем использовать третью форму спецификатора, один из
<pre> 
 struct идентификатор
 
 union идентификатор
</pre>
<p> Ярлыки структур дают возможность определения структур, которые ссылаются на самих себя; они также позволяют неоднократно использовать приведенную только один раз длинную часть описания. Запрещается описывать структуру или объединение, которые содержат образец самого себя, но структура или объединение могут содержать указатель на структуру или объединение такого же вида, как они сами.
<p>     Имена членов и ярлыков могут совпадать с именами обычных переменных. Однако имена ярлыков и членов должны быть взаимно различными.
<p>     Две структуры могут иметь общую начальную последовательность членов; это означает, что тот же самый член может появиться в двух различных структурах, если он имеет одинаковый тип в обеих структурах и если все предыдущие члены обеих структур одинаковы. (Фактически компилятор только проверяет, что имя в двух различных структурах имеет одинаковый тип и одинаковое смещение, но если предшествующие члены отличаются, то конструкция оказывается непереносимой).
<p>     Вот простой пример описания структуры:
<pre> 
  struct tnode {
  char tword[20];
  int count;
  struct tnode *left;
  struct tnode *right;
  };
</pre>
<p> Такая структура содержит массив из 20 символов, целое и два указателя на подобные структуры. Как только приведено такое описание, описание
<pre> 
    struct tnode s, *sp;
</pre> 
говорит о том, что s является структурой указанного вида, а sp является указателем на структуру указанного вида. При наличии этих описаний выражение
<pre> 
   sp-&gt;count
</pre> 
ссылается к полю count структуры, на которую указывает sp; выражение
<pre> 
   s.left
</pre> 
ссылается на указатель левого поддерева в структуре s, а выражение
<pre> 
   s.right-&gt;tword[0]
</pre> 
ссылается на первый символ члена tword правого поддерева из s.

<a name=166>
<h3>           16.6. Инициализация</h3>
<p>     Описатель может указывать начальное значение описываемого идентификатора. Инициализатор состоит из выражения или заключенного в фигурные скобки списка значений, перед которыми ставится знак =.
<br><br><i> 
   Инициализатор:<br>
   = выражение<br>
   = { список-инициализатора }<br>
   = { список-инициализатора, }<br><br>
   список-инициализатора:<br>
   выражение<br>
   список-инициализатора,список-инициализатора<br>
   { список-инициализатора }</i>
 
<p>     Все выражения, входящие в инициализатор статической или внешней переменной, должны быть либо константными выражениями, описываемыми в п. 23, Либо выражениями, которые сводятся к адресу ранее описанной переменной, возможно смещенному на константное выражение. Автоматические и регистровые переменные могут быть инициализированы произвольными выражениями, включающими константы и ранее описанные переменные и функции.
<p>     Гарантируется, что неинициализированные статические и внешние переменные получают в качестве начальных значений 0; неинициализированные автоматические и регистровые переменные в качестве начальных значений содержат мусор.
<p>     Когда инициализатор применяется к скаляру (указателю или объекту арифметического типа), то он состоит из одного выражения, возможно заключенного в фигурные скобки. Начальное значение объекта находится из выражения; выполняются те же самые преобразования, что и при присваивании.
<p>     Когда описываемая переменная является агрегатом (структурой или массивом ), то инициализатор состоит из заключенного в фигурные скобки и разделенного запятыми списка инициализаторов для членов агрегата. Этот список составляется в порядке возрастания индекса или в соответствии с порядком членов. Если агрегат содержит подагрегаты, то это правило применяется рекурсивно к членам агрегата. Если количество инициализаторов в списке оказывается меньше числа членов агрегата, то оставшиеся члены агрегата заполняются нулями. Запрещается инициализировать объединения или автоматические агрегаты.
<p>     Фигурные скобки могут быть опущены следующим образом. Если инициализатор начинается с левой фигурной скобки, то последующий разделенный запятыми список инициализаторов инициализирует члены агрегата; будет ошибкой, если в списке окажется больше инициализаторов, чем членов агрегата. Если однако инициализатор не начинается с левой фигурной скобки, то из списка берется только нужное для членов данного агрегата число элементов; оставшиеся элементы используются для инициализации следующего члена агрегата, частью которого является настоящий агрегат.
<p>     Последнее сокращение допускает возможность инициализации массива типа char с помощью строки. В этом случае члены массива последовательно инициализируются символами строки.
<p>     Например,
<pre> 
     int x[] = {1,3,5};
</pre> 
описывает и инициализирует x как одномерный массив; поскольку размер массива не специфицирован, а список инициализитора содержит три элемента, считается, что массив состоит из трех членов.
<p>     Вот пример инициализации с полным использованием фигурных скобок:
<pre> 
     float *y[4][3] = {
      ( 1, 3, 5 ),
      ( 2, 4, 6 ),
      ( 3, 5, 7 ),
     };
</pre> 
<p> Здесь 1, 3 и 5 инициализируют первую строку массива y[0], а именно y[0][0], y[0][1] и y[0][2]. Аналогичным образом следующие две строчки инициализируют y[1] и y[2]. Инициализатор заканчивается преждевременно, и, следовательно, массив y[3] инициализируется нулями. В точности такого же эффекта можно было бы достичь, написав
<pre> 
      float y[4][3] = {
       1, 3, 5, 2, 4, 6, 3, 5, 7
      };
</pre> 
<p> Инициализатор для y начинается с левой фигурной скобки, но инициализатора для y[0] нет. Поэтому используется 3 элемента из списка. Аналогично следующие три элемента используются последовательно для y[1] и y[2]. следующее описание
<pre> 
      float y[4][3] = {
       (1), (2), (3), (4)
      };
</pre> 
инициализирует первый столбец y (если его рассматривать как двумерный массив), а остальные элементы заполняются нулями.
<p>     И наконец, описание
<pre> 
     char msg[] = "SYNTAX ERROR ON LINE %s\n";
</pre> 
демонстрирует инициализацию элементов символьного массива с помощью строки.

<a name=167>
<h3>     16.7. Имена типов</h3>
<p>     В двух случаях (для явного указания типа преобразования в конструкции перевода и для аргументов операции sizeof) желательно иметь возможность задавать имя типа данных. Это осуществляется с помощью "имени типа", которое по существу является описанием объекта такого типа , в котором опущено имя самого объекта.
<br><br><i>     
    Имя типа:<br>
  спецификатор-типа абстрактный-описатель<br><br>
    абстрактный-описатель:<br>
  пусто<br>
  (абстрактный-описатель)<br>
  * абстрактный описатель<br>
  абстрактный-описатель ()<br>
  абстрактный-описатель [константное выражение<sub>необ</sub>]</i>
 
<p> Во избежании двусмысленности в конструкции
<I>
      (абстрактный описатель)
</I> 
требуется, чтобы абстрактный-описатель был непуст. При этом ограничении возможно однозначно определить то место в абстрактном-описателе, где бы появился идентификатор, если бы эта конструкция была описателем в описании. Именованный тип совпадает тогда с типом гипотетического идентификатора. Например, имена типов
<pre> 
  int
  int *
  int *[3]
  int (*)[3]
  int *()
  int (*)()
</pre> 
именуют соответственно типы "целый", "указатель на целое", "массив из трех указателей на целое", "указатель на массив из трех целых", " функция, возвращающая указатель на целое" и "указатель на функцию, возвращающую целое".

<a name=168>
<h3>     16.8. typedef</h3>
<p>     Описания, в которых "класс памяти" специфицирован как typedef, не вызывают выделения памяти. вместо этого они определяют идентификаторы ,которые позднее можно использовать так, словно они являются ключевыми словами, имеющими основные или производные типы.
<br><br><i>  Определяющее-тип-имя<br>
  идентификатор</i>
 
<p> В пределах области действия описания со спецификатором typedef каждый идентификатор, являющийся частью любого описателя в этом описании, становится синтаксически эквивалентным ключевому слову, имеющему тот тип , который ассоциирует с идентификатором в описанном в п. 16.4 смысле. Например, после описаний
<pre> 
  typedef int miles, clicksp;
  typedef struct ( double re, im; ) complex;
</pre> 
конструкции
<pre> 
  miles distance;
  extern clicksp metricp;
  complex z, *zp;
</pre>
становятся законными описаниями; при этом типом distance является int, типом metricp - "указатель на int", типом z - специфицированная структура и типом zp - указатель на такую структуру.
<p>     Спецификатор typedef не вводит каких-либо совершенно новых типов, а только определяет синонимы для типов, которые можно было бы специфицировать и другим способом. Так в приведенном выше примере переменная distance считается имеющей точно такой же тип, что и любой другой объект, описанный в int.

<a name=17>
<h2>     17. Операторы</h2>
<p>     За исключением особо оговариваемых случаев, операторы выполняются последовательно.

<a name=171>
<h3>     17.1. Операторное выражение</h3>
<p>     Большинство операторов являются операторными выражениями, которые имеют форму
<br><br><i> 
      выражение;
</i> <br><br>
обычно операторные выражения являются присваиваниями или обращениями к функциям.

<a name=172>
<h3>     17.2. Составной оператор (или блок) </h3>
<p>     С тем чтобы допустить возможность использования нескольких операторов там, где ожидается присутствие только одного, предусматривается составной оператор (который также и эквивалентно называют "блоком"):
<br><br><i> 
     составной оператор:<br>
    {список-описаний<sub>необ</sub>    список-операторов<sub>необ</sub>}<br><br>
     список-описаний:<br>
    описание<br>
    описание список-описаний<br><br>
     список-операторов:<br>
    оператор<br>
    оператор список-операторов</i>
 
<p> Если какой-либо идентификатор из списка-описаний был описан ранее, то во время выполнения блока внешнее описание подавляется и снова вступает в силу после выхода из блока.
<p>     Любая инициализация автоматических и регистрационных переменных проводится при каждом входе в блок через его начало. В настоящее время разрешается (но это плохая практика) передавать управление внутрь блока; в таком случае эти инициализации не выполняются. Инициализации статических переменных проводятся только один раз, когда начинается выполнение программы.
<p>     Находящиеся  внутри блока внешние описания не резервируют памяти, так что их инициализация не разрешается.
<a name=173>          
<h3>     17.3. Условные операторы</h3>
<p>     Имеются две формы условных операторов:
<br><br><i> 
    if (выражение) оператор<br>
    if (выражение) оператор else оператор</i>
 
<p> В обоих случаях вычисляется выражение и, если оно отлично от нуля, то выполняется первый подоператор. Во втором случае, если выражение равно нулю, выпалняется второй подоператор. Как обычно, двусмысленность "else" разрешается связываением else с последним встречающимся if, у которого нет else.

<a name=174>
<h3>     17.4. Оператор while</h3>
<p>     Оператор while имеет форму
<br><br><i> 
      while (выражение) оператор</i>
 
<p> Подоператор выполняется повторно до тех пор, пока значение выражения остается отличным от нуля. проверка производится перед каждым выполнением оператора.

<a name=175>
<h3>     17.5. Оператор do</h3>
<p>     Оператор do имеет форму
<br><br><i> 
 do оператор while (выражения)</i>
 
<p>     Оператор выполняется повторно до тех пор, пока значение выражения не станет равным нулю. Проверка производится после каждого выполнения оператора.

<a name=176>
<h3>     17.6. Оператор for</h3>
<p>     Оператор for имеет форму
<br><br><i> 
 (выражение-1<sub>необ</sub>  ; выражение-2<sub>необ</sub> ; выражение-3 <sub>необ</sub> )оператор<br>
</i> 
<p>  Оператор for эквивалентен следующему
<br><br><i> 
  выражение-1;<br>
     while   (выражение-2) {<br>
        оператор<br>
        выражение-3<br>
  }</i>
 
<p> Таким образом, первое выражение определяет инициализацию цикла; второе специфиуирует проверку, выполняемую перед каждой итерацией, так что выход из цикла происходит тогда, когда значение выражения становится нулем; третье выражение часто задает приращение параметра, которое проводится после каждой итерации.
<p>     Любое выражение или даже все они могут быть опущены. Если отсутствует второе выражение, то предложение с while считается эквивалентным while(1); другие отсутствующие выражения просто опускаются из приведенного выше расширения.
     
<a name=177>
<h3>     17.7. Оператор switch</h3>
<p>     Оператор switch (переключатель), вызывает передачу управления к одному из нескольких операторов, в зависимости от значения выражения. Оператор имеет форму
<br><br><i> 
  switch (выражение) оператор</i>
 
<p> В выражении проводятся обычные арифметические преобразования, но результат должен иметь тип int. Оператор обычно является составным. Любой оператор внутри этого оператора может быть помечен одним или более вариантным префиксом case, имеющим форму:
 
  case констанстное выражение:
 
где константное выражение должно иметь тип int. Никакие две вариантные константы в одном и том же переключателе не могут иметь одинаковое значение. точное определение константного выражения приводится в п. 23.
<p>     Кроме того, может присутствовать самое большее один операторный префикс вида
<br><br><i>     
  default:</i>
 
<p>     При выполнении оператора switch вычисляется входящее в него выражение и сравнивается с каждой вариантной константой. Если одна из вариантных констант оказывается равной значению этого выражения, то управление передается оператору, который следует за совпадающим вариантным префиксом. Если ни одна из вариантных констант не совпадает со значением выражения и если при этом присутствует префикс default, то управление передается оператору, помеченному этим префиксом. если ни один из вариантов не подходит и префикс default отсутствует, то ни один из операторов в переключателе не выполняется.
<p>     Сами по себе префиксы case и default не изменяют поток управления, которое беспрепятственно проходит через такие префиксы. Для выхода из переключателя смотрите оператор break, п. 17.8.
<p>     Обычно оператор, который входит в переключатель, является составным. Описания могут появляться в начале этого оператора, но инициализации автоматических и регистровых переменных будут неэффективными.

<a name=178>
<h3>     17.8. Оператор break</h3>
<p>     Оператор
<br><br><i> 
 break;    </i>
<br><br> 
вызывает завершение выполнения наименьшего охватывающего этот оператор оператора while, do, for или switch; управление передается оператору, следующему за завершенным оператором.

<a name=179>     
<h3>     17.9. Оператор continue</h3>
<p>     Оператор
<br><br><i> 
  continue;</i>
<br><br> 
приводит к передаче управления на продолжающую цикл часть наименьшего охватывающего этот оператор оператора while, do или for; то есть на конец цикла. Более точно, в каждом из операторов
<pre> 
   while(...) {       do {             for(...) {
      ...                ...              ...
   CONTIN: ;          CONTIN: ;        CONTIN: ;
   }                  } while(...);    }
</pre> 
<p> Оператор continue эквивалентен оператору goto CONTIN. (За CONTIN: следует пустой оператор; см. п. 17.13.).

<a name=1710>
<h3>     17.10. Оператор возврата</h3>
<p>     Возвращение из функции в вызывающую программу осуществляется с помощью оператора return, который имеет одну из следующих форм
<br><br><i> 
   return;<br>
    return выражение;</i>
 
<p> В первом случае возвращаемое значение не определено. Во втором случае в вызывающую функцию возвращается значение выражения. Если требуется, выражение преобразуется к типу функции, в которой оно появляется, как в случае присваивания. Попадание на конец функции эквивалентно возврату без возвращаемого значения.

<a name=1711>
<h3>     17.11. Оператор goto</h3>
<p>     Управление можно передавать безусловно с помощью оператора
<br><br><i> 
     goto идентификатор</i><br><br>
 
идентификатор должен быть меткой (п. 9.12), Локализованной в данной функции.

<a name=1712>
<h3>     17.12. Помеченный оператор</h3>
<p>     Перед любым оператором может стоять помеченный префикс вида
<br><br><i>     идентификатор:</i><br><br>
 
который служит для описания идентификатора в качестве метки. Метки используются только для указания места, куда передается управление оператором goto. Областью действия метки является данная функция, за исключением любых подблоков, в которых тот же идентификатор описан снова. Смотри п. 19.
     
<a name=1713>
<h3>     17.13. Пустой оператор</h3>
<p>     Пустой оператор имеет форму:
<br><br><i>     
   ;   </i>
 
<p> Пустой оператор оказывается полезным, так как он позволяет поставить метку перед закрывающей скобкой } составного оператора или указать пустое тело в операторах цикла, таких как while.

<a name=18>
<h2>     18. Внешние определения</h2>
<p>     C-программа представляет собой последовательность внешних определений. Внешнее определение описывает идентификатор как имеющий класс памяти extern (по умолчанию), или возможно static, и специфицированный тип. Спецификатор типа (п. 16.2) также может быть пустым; в этом случае считается, что тип является типом int. Область действия внешних определений распространяется до конца файла, в котором они приведены, точно так же , как влияние описаний простирается до конца
 блока. Синтаксис внешних определений не отличается от синтаксиса описаний, за исключением того, что только на этом уровне можно приводить текст функций.

<a name=181>
<h3>     18.1. Внешнее определение функции</h3>
<p>     Определение функции имеет форму
<br><br> <i>
     определение-функции:<br>
 
     спецификаторы-описания   описатель-функции<br>
 тело-функции<sub>необ</sub></i>
 
<p> Единственными спецификаторами класса памяти, допускаемыми в качестве спецификаторов-описания, являются extern или static; о различии между ними смотри п. 19.2. Описатель функции подобен описателю для "функции, возвращающей...", за исключением того, что он перечисляет формальные параметры определяемой функции.
<br><br> <i>
   Описатель-функции:<br>
  описатель (список-параметров<sub>необ</sub>)<br><br>
   список параметров:<br>
   идентификатор<br>
   идентификатор, список-параметров</i><br><br>
 
тело-функции имеет форму
<br><br><i> 
    тело-функции:<br>
   список-описаний составной-оператор</i>
     
<p>     Идентификаторы из списка параметров и только они могут быть описаны в списке описаний. Любой идентификатор, тип которого не указан, считается имеющим тип int. Единственным допустимым здесь спецификатором класса памяти является register; если такой класс памяти специфицирован, то в начале выполнения функции соответствующий фактический параметр копируется, если это возможно, в регистр.
<p>     Вот простой пример полного определения функции:
<pre> 
   int max(a, b, c)
   int a, b, c;
   {
     int m;
     m = (a&gt;b) ? a:b;
     return((m&gt;c) ? m:c);
   }
</pre> 
Здесь int - спецификатор-типа, max(a,b,c) - описатель-функции, int a,b,c; - список-описаний формальных параметров, { ... } - блок, содержащий текст оператора.
<p>     В языке C все фактические параметры типа float преобразуются к типу double, так что описания формальных параметров, объявленных как float, приспособлены прочесть параметры типа double. Аналогично, поскольку ссылка на массив в любом контексте (в частности в фактическом параметре) рассматривается как указатель на первый элемент массива, описания формальных параметров вила "массив ..." приспособлены прочесть: "указатель на ...". И наконец, поскольку структуры, объединения и функции не могут быть переданы функции, бессмысленно описывать формальный параметр как структуру, объединение или функцию (указатели на такие объекты, конечно, допускаются).

<a name=182>
<h3>     18.2. Внешние определения данных</h3>
 
<p>     Внешнее определение данных имеет форму
<br><br><i> 
  определение-данных:<br>
    описание</i>
 
<p> Классом памяти таких данных может быть extern (в частности, по умолчанию) или static, но не auto или register.

<a name=19>
<h2>     19. Правила, определяющие область действия</h2>
<p>     Вся C-программа необязательно компилируется одновременно; исходный текст программы может храниться в нескольких файлах и ранее скомпилированные процедуры могут загружаться из библиотек. Связь между функциями может осуществляться как
 через явные обращения, так и в результате манипулирования с внешними данными.
<p>     Поэтому следует рассмотреть два вида областей действия: во-первых, ту, которая может быть названа лексической областью действия идентификатора и которая по существу является той областью в программе, где этот идентификатор можно использовать, не вызывая диагностического сообщения "неопределенный идентификатор"; и во-вторых, область действия, которая связана с внешними идентификаторами и которая характеризуется правилом, что ссылки на один и тот же внешний идентификатор являются ссылками на один и тот же объект.
     
<a name=191>
<h3>     19.1. Лексическая область действия</h3>
<p>     Лексическая область действия идентификаторов, описанных во внешних определениях, простирается от определения до конца исходного файла, в котором он находится. Лексическая область действия идентификаторов, являющихся формальными параметрами, распространяется на ту функцию, к которой они относятся. Лексическая область действия идентификаторов, описанных в начале блока, простирается до конца этого блока. Лексической областью действия меток является та функция, в которой они находятся.
<p>     Поскольку все обращения на один и тот же внешний идентификатор обращаются к одному и тому же объекту (см. п. 19.2). Компилятор проверяет все описания одного и того же внешнего идентификатора на совместимость; в действительности их область действия распространяется на весь файл, в котором они находятся.
<p>     Во всех случаях, однако, есть некоторый идентификатор, явным образом описан в начале блока, включая и блок, который образует функцию, то действие любого описания этого идентификатора вне блока приостанавливается до конца этого блока.
<p>     Напомним также (п. 16.5), Что идентификаторы, соответствующие обычным переменным, с одной стороны, и идентификаторы, соответствующие членам и ярлыкам структур и объединений, с другой стороны, формируют два непересекающихся класса, которые не вступают в противоречие. Члены и ярлыки подчиняются тем же самым правилам определения областей действия, как и другие идентификаторы. Имена, специфицируемые с помощью typedef, входят в тот же класс, что и обычные идентификаторы. Они могут быть переопределены во внутренних блоках, но во внутреннем описании тип должен быть указан явно:
<pre> 
  typedef float distance;
  ...
  {
     auto int distance;
     ...
</pre> 
<p> Во втором описании спецификатор типа int должен присутствовать, так как в противном случае это описание будет принято за описание без описателей с типом distance (прим. авторов: согласитесь, что лед здесь тонок.).

<a name=192>
<h3>     19.2. Область действия внешних идентификаторов</h3>
<p>     Если функция ссылается на идентификатор, описанный как extern, то где-то среди файлов или библиотек, образующих полную программу, должно содержаться внешнее определение этого идентификатора. Все функции данной программы, которые ссылаются на один и тот же внешний идентификатор, ссылаются на один и тот же объект, так что следует позаботиться, чтобы специфицированные в этом определении тип и размер были совместимы с типом и размером, указываемыми в каждой функции,
 которая ссылается на эти данные.
<p>     Появление ключевого слова extern во внешнем определении указывает на то, что память для описанных в нем идентификаторов будет выделена в другом файле. Следовательно, в состоящей из многих файлов программе внешнее определение идентификатора, не содержащее спецификатора extern, должно появляться ровно в одном из этих файлов. любые другие файлы, которые желают дать внешнее определение этого идентификатора, должны включать в это определение слово extern. Идентификатор может быть инициализирован только в том описании, которое приводит к выделению памяти.
<p>     Идентификаторы, внешнее определение которых начинается со слова static, недоступны из других файлов. Функции могут быть описаны как static.

<a name=20>
<h2>     20. Строки управления компилятором</h2>
<p>     Компилятор языка C содержит препроцессор, который позволяет осуществлять макроподстановки, условную компиляцию и включение именованных файлов. Строки, начинающиеся с #, общаются с этим препроцессором. Синтаксис этих строк не связан с остальным языком; они могут появляться в любом месте и их влияние распространяется (независимо от области действия) до конца исходного программного файла.

<a name=201>
<h3>     20.1. Замена лексем</h3>
<p>     Управляющая компилятором строка вида
<br><br><i> 
 #define идентификатор строка-лексем
</i> 
<p> (Обратите внимание на отсутствие в конце точки с запятой) приводит к тому, что препроцессор заменяет последующие вхождения этого идентификатора на указанную строку лексем.
 Строка вида
<br><br><i> 
 #define        идентификатор<br>
 (идентификатор,...,идентификатор)строка лексем
</i><br><br> 
 где между первым идентификатором и открывающейся скобкой ( нет пробела, представляет собой макроопределение с аргументами. Последующее вхождение первого идентификатора, за которым следует открывающая скобка '(', последовательность разделенных запятыми лексем и закрывающая скобка ')', заменяются строкой лексем из определения. каждое вхождение идентификатора, упомянутого в списке формальных параметров в определении , заменяется соответствующей строкой лексем из обращения. Фактическими аргументами в обращении являются строки лексем, разделенные запятыми; однако запятые, входящие в закавыченные строки или заключенные в круглые скобки, не разделяют аргументов. Количество формальных и фактических параметров должно совпадать. Текст внутри строки или символьной
 константы не подлежит замене.
<p>     В обоих случаях замененная строка просматривается снова с целью обнаружения других определенных идентификаторов. В обоих случаях слишком длинная строка определения может быть продолжена на другой строке, если поместить в конце продолжаемой строки обратную косую черту \.
<p>     Описываемая возможность особенно полезна для определения "объявляемых констант", как, например,
<pre> 
  #define TABSIZE 100
  int table[TABSIZE];
</pre> 
<p> Управляющая строка вида
<br><br><i> 
  #undef идентификатор
</i><br><br> 
приводит к отмене препроцессорного определения данного идентификатора.

<a name=202>
<h3>     20.2. Включение файлов</h3>
<p>     Строка управления компилятором вида
<br><br><i> 
  #include "filename"
</i> <br><br>
приводит к замене этой строки на все содержимое файла с именем filename. Файл с этим именем сначала ищется в справочнике начального исходного файла, а затем в последовательности стандартных мест. В отличие от этого управляющая строка вида
<br><br><i> 
  #include &lt; filename &gt;
</i> <br><br>
 ищет файл только в стандартных местах и не просматривает справочник исходного файла.
<p>     Строки #include могут быть вложенными.

<a name=203>
<h3>     20.3. Условная компиляция</h3>
<p>     Строка управления компилятором вида
<br><br><i> 
 #if константное выражение
</i><br><br> 
проверяет, отлично ли от нуля значение константного выражения (см. п. 15). Управляющая строка вида
<br><br><i> 
 #ifdef идентификатор
</i><br><br> 
проверяет, определен ли этот идентификатор в настоящий момент в препроцессоре, т.е. Определен ли этот идентификатор с помощью управляющей строки #define.

<a name=21>
<h2>     21. Неявные описания</h2>
<p>     Не всегда является необходимым специфицировать и класс памяти и тип идентификатора в описании. Во внешних определениях и описаниях формальных параметров и членов структур класс памяти определяется по контексту. Если в находящемся внутри функции описании не указан тип, а только класс памяти, то предполагается, что идентификатор имеет тип int; если не указан класс памяти, а только тип, то идентификатор предполагается описанным как auto. Исключение из последнего правила дается для функций, потому что спецификатор auto для
 функций является бессмысленным (язык C не в состоянии компилировать программу в стек); если идентификатор имеет тип "функция, возвращающая ...", то он предполагается неявно описанным как extern.
<p>     Входящий в выражение и неописанный ранее идентификатор, за которым следует скобка (, считается описанным по контексту как "функция, возвращающая int".

<a name=22>
<h2>     22. Снова о типах</h2>
<p>     В этом разделе обобщаются сведения об операциях, которые можно применять только к объектам определенных типов.
<a name=221>
<h3>     22.1. Структуры и объединения</h3>
<p>     Только две вещи можно сделать со структурой или объединением: назвать один из их членов (с помощью операции) или извлечь их адрес (с помощью унарной операции &). Другие операции, такие как присваивание им или из них и передача их в качестве параметров, приводят к сообщению об ошибке. В будущем ожидается, что эти операции, но не обязательно какие-либо другие, будут разрешены.
<p>     В п. 15.1 Говорится, что при прямой или косвенной ссылке на структуру (с помощью . или -&gt;) имя справа должно быть членом структуры, названной или указанной выражением слева. Это ограничение не навязывается строго компилятором, чтобы дать возможность обойти правила типов. В действительности перед '.' допускается любое L-значение и затем предполагается, что это L-значение имеет форму структуры, для которой стоящее справа имя является членом. Таким же образом, от выражения, стоящего перед '-&gt;', требуется только быть указателем или целым. В случае указателя предполагается, что он указывает на структуру, для которой стоящее справа имя является членом. В случае целого оно рассматривается как абсолютный адрес соответствующей структуры, заданный в единицах машинной памяти.
<p>     Такие структуры не являются переносимыми.

<a name=222>
<h3>     22.2. Функции</h3>
<p>     Только две вещи можно сделать с функцией: вызвать ее или извлечь ее адрес. Если имя функции входит в выражение не в позиции имени функции, соответствующей обращению к ней, то генерируется указатель на эту функцию. Следовательно, чтобы передать одну функцию другой, можно написать
<pre> 
  int f();
  ...
  g(f);
</pre> 
Тогда определение функции g могло бы выглядеть так:
<pre> 
 g(funcp)
 int(*funcp)();
 {
    ...
    (*funcp)();
    ...
 }
</pre> 
<p> Обратите внимание, что в вызывающей процедуре функция f должна быть описана явно, потому что за ее появлением в g(f) не следует скобка (.
     
<a name=223>
<h3>     22.3. Массивы, указатели и индексация</h3>
<p>     Каждый раз, когда идентификатор, имеющий тип массива, появляется в выражении, он преобразуется в указатель на первый член этого массива. Из-за этого преобразования массивы не являются L-значениями. По определению операция индексация [] интерпретируется таким образом, что e1[e2] считается идентичным выражению *((е1)+(е2)). Согласно правилам преобразований, применяемым при операции +, если e1 - массив, а е2 - целое, то е1[е2] ссылается на е2-й член массива е1. Поэтому несмотря на несимметричный вид операция индексации является коммутативной.
<p>     В случае многомерных массивов применяется последовательное правило. Если е является n-мерным массивом размера i*j*...*k, то при появлении в выражении е преобразуется в указатель на (n-1)-мерный массив размера j*...*k. Если операция * либо явно, либо неявно, как результат индексации, применяется к этому указателю, то результатом операции будет указанный (n-1)-мерный массив, который сам немедленно преобразуется в указатель.
<p>     Рассмотрим, например, описание
<pre> 
 int x[3][5];
</pre> 
 Здесь x массив целых размера 3*5. При появлении в выражении x преобразуется в указатель на первый из трех массивов из 5 целых. В выражении x[i], которое эквивалентно *(x+i), сначала x преобразуется в указатель так, как описано выше; затем i преобразуется к типу x, что вызывает умножение i на длину объекта, на который указывает указатель, а именно на 5 целых объектов. Результаты складываются, и применение косвенной адресации дает массив (из 5 целых), который в свою очередь преобразуется в указатель на первое из этих целых. Если в выражение входит и другой индекс, то та же самая аргументация применяется снова; результатом на этот раз будет целое.
<p>     Из всего этого следует, что массивы в языке C хранятся построчно ( последний индекс изменяется быстрее всего) и что первый индекс в описании помогает определить общее количество памяти, требуемое для хранения массива, но не играет никакой другой роли в вычислениях, связанных с индексацией.

<a name=224>
<h3>     22.4. Явные преобразования указателей</h3>
<p>     Разрешаются определенные преобразования, с использованием указателей , но они имеют некоторые зависящие от конкретной реализации аспекты. Все эти преобразования задаются с помощью операции явного преобразования типа; см. п. 15.2 и 16.7.
<p>     Указатель может быть преобразован в любой из целочисленных типов, достаточно большой для его хранения. Требуется ли при этом int или long, зависит от конкретной машины. Преобразующая функция также является машинно-зависимой, но она будет вполне естественной для тех, кто знает структуру адресации в машине. Детали для некоторых конкретных машин приводятся ниже.
<p>     Объект целочисленного типа может быть явным образом преобразован в указатель. такое преобразование всегда переводит преобразованное из указателя целое в тот же самый указатель, но в других случаях оно будет машинно-зависимым.
<p>     Указатель на один тип может быть преобразован в указатель на другой тип. Если преобразуемый указатель не указывает на объекты, которые подходящим образом выравнены в памяти, то результирующий указатель может при использовании вызывать ошибки адресации. Гарантируется, что указатель на объект заданного размера может быть преобразован в указатель на объект меньшего размера и снова обратно, не претерпев при этом изменения.
<p>     Например, процедура распределения памяти могла бы принимать запрос на размер выделяемого объекта в байтах, а возвращать указатель на символы; это можно было бы использовать следующим образом.
<pre> 
  extern char *alloc();
  double *DP;
  DP=(double*) alloc(sizeof(double));
  *DP=22.0/7.0;
</pre> 
<p> Функция alloc должна обеспечивать (машинно-зависимым способом), что возвращаемое ею значение будет подходящим для преобразования в указатель на double; в таком случае использование этой функции будет переносимым.
<p>     Представление указателя на PDP-11 соответствует 16-битовому целому и измеряется в байтах. Объекты типа char не имеют никаких ограничений на выравнивание; все остальные объекты должны иметь четные адреса.
<p>     На HONEYWELL 6000 указатель соответствует 36-битовому целому; слову соответствует 18 левых битов и два непосредственно примыкающих к ним справа бита, которые выделяют символ в слове. Таким образом, указатели на символы измеряются в единицах 2 в степени 16 байтов; все остальное измеряется в единицах 2 в степени 18 машинных слов. Величины типа double и содержащие их агрегаты должны выравниваться по четным адресам слов (0 по модулю 2 в степени 19). ЭВМ IBM 370 и INTERDATA 8/32 сходны между собой. На обеих машинах адреса измеряются в байтах; элементарные объекты должны быть выровнены по границе, равной их длине, так что указатели на short должны быть кратны двум, на int и float - четырем и на double - восьми. Агрегаты выравниваются по самой строгой границе, требуемой каким-либо из их элементов.

<a name=23>
<h2>     23. Константные выражения</h2>
<p>     В нескольких местах в языке C требуются выражения, которые после вычисления становятся константами: после вариантного префикса case, в качестве границ массивов и в инициализаторах. В первых двух случаях выражение может содержать только целые константы, символьные константы и выражения sizeof, возможно связанные либо бинарными операциями
<pre> 
  + - * / . % & | ^ &lt;&lt; &gt;&gt; == != &lt; &gt; &lt;= &gt;=
<pre> 
 либо унарными операциями
<pre> 
 - ~
</pre> 
 либо тернарной операцией ?:
     
<p> Круглые скобки могут использоваться для группировки, но не для обращения к функциям.
 
<p>     В случае инициализаторов допускается большая (ударение на букву о) свобода; кроме перечисленных выше константных выражений можно также применять унарную операцию & к внешним или статическим объектам и к внешним или статическим массивам, имеющим в качестве индексов константное выражение. Унарная операция & может быть также применена неявно, в результате появления неиндексированных массивов и функций. Основное правило заключается в том, что после вычисления инициализатор должен становится либо константой, либо адресом ранее описанного внешнего или статического объекта плюс или минус константа.

<a name=24>
<h2>     24. Соображения о переносимости</h2>
<p>     Некоторые части языка C по своей сути машинно-зависимы. Следующие ниже перечисление потенциальных трудностей хотя и не являются всеобъемлющими, но выделяет основные из них.
<p>     Как показала практика, вопросы, целиком связанные с аппаратным оборудованием, такие как размер слова, свойства плавающей арифметики и целого деления, не представляют особенных затруднений. Другие аспекты аппаратных средств находят свое отражение в различных реализациях. Некоторые из них, в частности, знаковое расширение (преобразующее отрицательный символ в отрицательное целое) и порядок, в котором помещаются байты в слове, представляют собой неприятность, которая должна тщательно отслеживаться. Большинство из остальных проблем этого типа не вызывает сколько-нибудь значительных затруднений.
<p>     Число переменных типа register, которое фактически может быть помещено в регистры, меняется от машины к машине, также как и набор допустимых для них типов. Тем не менее все компиляторы на своих машинах работают надлежащим образом; лишние или недопустимые регистровые описания игнорируются.
<p>     Некоторые трудности возникают только при использовании сомнительной практики программирования. Писать программы, которые зависят от каких- либо этих свойств, является чрезвычайно неразумным.
<p>     Языком не указывается порядок вычисления аргументов функций; они вычисляются справа налево на PDP-11 и VAX-11 и слева направо на остальных машинах. порядок, в котором происходят побочные эффекты, также не специфицируется.
<p>     Так как символьные константы в действительности являются объектами типа int, допускается использование символьных констант, состоящих из нескольких символов. Однако, поскольку порядок, в котором символы приписываются к слову, меняется от машины к машине, конкретная реализация оказывается весьма машинно-зависимой.
<p>     Присваивание полей к словам и символов к целым осуществляется справа налево на PDP-11 и VAX-11 и слева направо на других машинах. эти различия незаметны для изолированных программ, в которых не разрешено смешивать типы (преобразуя, например, указатель на int в указатель на char и затем проверяя указываемую память), но должны учитываться при согласовании с накладываемыми извне схемами памяти.
<p>     Язык, принятый на различных компиляторах, отличается только незначительными деталями. Самое заметное отличие состоит в том, что используемый в настоящее время компилятор на PDP-11 не инициализирует структуры, которые содержат поля битов, и не допускает некоторые операции присваивания в определенных контекстах, связанных с использованием значения присваивания.

<a name=25>
<h2>     25. Анахронизмы</h2>
<p>     Так как язык C является развивающимся языком, в старых программах можно встретить некоторые устаревшие конструкции. Хотя большинство версий компилятора поддерживает такие анахронизмы, они в конце концов исчезнут, оставив за собой только проблемы переносимости.
<p>     В ранних версиях C для проблем присваивания использовалась форма =ON, а не ON=, приводя к двусмысленностям, типичным примером которых является
<pre>     
 x = -1
</pre> 
где x фактически уменьшается, поскольку операции = и - примыкают друг к другу, но что вполне могло рассматриваться и как присваивание -1 к x.
<p>     Синтаксис инициализаторов изменился: раньше знак равенства, с которого начинается инициализатор, отсутствовал, так что вместо
<pre> 
 int x = 1;
</pre> 
 использовалось
<pre> 
 int x 1;
</pre> 
изменение было внесено из-за инициализации
<pre> 
 int f (1+2)
</pre> 
 которая достаточно сильно напоминает определение функции,
 чтобы смутить компиляторы.

<a name=26>
<h2>     26. Сводка синтаксических правил</h2>
<p>     Эта сводка синтаксиса языка C предназначена скорее для облегчения понимания и не является точной формулировкой языка.

<a name=261>
<h3>     26.1. Выражения</h3>
<p>     Основными выражениями являются следующие:
<br><br><i> 
    выражение:<br>
     первичное-выражение<br>
   * выражение<br>
   & выражение<br>
   - выражение<br>
   ! выражение<br>
  ~ выражение<br>
  ++ L-значение<br>
  -- L-значение<br>
   L-значение ++<br>
   L-значение --<br>
   sizeof выражение<br>
   (имя типа) выражение<br>
   выражение бинарная-операция выражение<br>
   выражение ? выражение : выражение<br>
   L-значение операция-присваивания выражение<br>
   выражение , выражение<br><br>

    первичное выражение:<br>
   идентификатор<br>
   константа<br>
   строка<br>
   (выражение)<br>
   первичное-выражение (список выражений<sub>необ</sub>)<br>
   первичное-выражение [выражение]<br>
   L-значение . Идентификатор<br>
   первичное выражение -&gt; идентификатор<br><br>

    L-значение:<br>
   идентификатор<br>
   первичное-выражение [выражение]<br>
   L-значение.идентификатор<br>
   первичное-выражение -&gt; идентификатор<br>
   * выражение<br>
   (L-значение)</i>
 
<p> Операции первичных выражений<br>
<pre> 
   () []  .  -&gt;
</pre>
 
имеют самый высокий приоритет и группируются слева направо. Унарные операции
<pre>     
   *  &  -  !  ~  ++  --  sizeof(Имя типа)
</pre>
 
имеют более низкий приоритет, чем операции первичных выражений, но более высокий, чем приоритет любой бинарной операции. Эти операции группируются справа налево. Все бинарные операции и условная операция (прим. перевод.: условная операция группируется справа налево; это изменение внесено в язык в 1978 г.) группируются слева направо и их приоритет убывает в следующем порядке:
 
<p>Бинарные операции:
<pre>
       *   /   %
       +   -
       &gt;&gt;  &lt;&lt;
       &lt;   &gt;  &lt;=   &gt;=
       ==  !=
       &
       ~
       |
       &&
       ||
       ?:
</pre>     
<p> Все операции присваивания имеют одинаковый приоритет и группируются справа налево.
<p> Операции присваивания:
<pre>
   =  +=  -=  *=  ?=  %=  &gt;&gt;=  &lt;&lt;=  &=  ~=  |=
</pre> 
 Операция запятая имеет самый низкий приоритет и группируется
 слева направо.

<a name=262>
<h3>     26.2. Описания</h3>
<i> Описание:<br>

 спецификаторы-описания список-инициализируемых-описателей<sub>необ</sub>;<br><br>

 спецификаторы-описания:<br> 
   спецификатор-типа спецификаторы-описания<sub>необ</sub><br>
   спецификатор-класса-памяти спецификаторы-описания<sub>необ</sub><br><br>
 спецификатор-класса-памяти:<br>
  auto<br>
  static<br>
  extern<br>
  register<br>
  typedef<br><br>

 спецификатор-типа:<br>
   char<br>
   short<br>
   int<br>
   long<br>
   unsigned<br>
   float<br>
   double<br>
    спецификатор-структуры-или-объединения<br>
    определяющее-тип-имя<br><br>
 список-инициализируемых-описателей:<br>
    инициализируемый-описатель<br>
    инициализируемый-описатель,<br>
    список-инициализируемых-описателей<br><br>
 инициализируемый-описатель<br>
   описатель-инициализатор<sub>необ</sub><br><br>
 описатель:<br>
    идентификатор<br>
    (описатель)<br>
    * описатель<br>
    описатель ()<br>
    описатель [константное выражение<sub>необ</sub>]<br><br>

 спецификатор-структуры-или-объединения:<br>
    struct список-описателей-структуры<br>
    struct идентификатор {список-описаний-структуры}<br>
    struct идентификатор<br>
    union {список-описаний-структуры}<br>
    union идентификатор {список-описаний-структуры}<br>
    union идентификатор<br><br>
 список-описаний-структцры:<br>
    описание-структуры<br>
    описание-структуры список-описаний-структуры<br><br>

 описание структуры:<br>
    спецификатор-типа список-описателей-структуры:<br>
 список-описателей-структуры<br>
    описатель-структуры<br>
    описатель-структуры,список-описателей-структуры<br><br>

 описатель-структуры:<br>
    описатель<br>
    описатель: константное выражение<br>
    :константное-выражение<br><br>

 инициализатор:<br>
    = выражение<br>
    = {список-инициализатора}<br>
    = {список-инициализатора}<br><br>

 список инициализатора:<br>
    выражение<br>
    список-инициализатора,список-инициализатора<br>
    {список-инициализатора}<br><br>

 имя-типа:<br>
    спецификатор-типа абстрактный-описатель<br><br>

 абстрактный-описатель:<br>
    пусто<br>
    {абстрактный-описатель}<br>
    * абстрактный-описатель<br>
    абстрактный-описатель ()<br>
    абстрактный-описатель [константное-выражение<sub>необ</sub>]<br><br>

 определяющее-тип-имя:<br>
   идентификатор</i>

<a name=263>
<h3>     26.3. Операторы</h3>
<i> составной-оператор:<br>
   {список-описаний<sub>необ</sub>список-операторов<sub>необ</sub>}<br><br>

 список-описаний:<br>
   описание<br>
   описание список-описаний<br><br>

 список-операторов:<br>
   оператор<br>
   оператор список-операторов<br><br>

 оператор:<br>
   составной оператор<br>
   выражение;<br>     
   if (выражение) оператор<br>
   if (выражение) оператор else оператор<br>
   while (выражение) оператор<br>
   do оператор while (выражение);<br>
   for(выражение-1<sub>необ</sub>    ;выражение-2<sub>необ</sub> ;выражение-3<sub>необ</sub>)  оператор<br>
   switch (выражение) оператор<br>
   case константное-выражение : оператор<br>
   default: оператор<br>
   break;<br>
   continue;<br>
   return;<br>
   return выражение;<br>
   goto идентификатор;<br>
   идентификатор : оператор<br>
   ;</i>

<a name=264>
<h3>     26.4. Внешние определения</h3>
<i> Программа:<br>
   внешнее-определение<br>
   внешнее-определение программа<br><br>

 внешнее-определение:<br>
   определение-функции<br>
   определение-данных<br><br>

 определение-функции:<br>
   спецификатор-типа<sub>необ</sub>     описатель-функции тело-функции<br><br>

 описатель-функции:<br>
   описатель (список-параметров<sub>необ</sub>)<br><br>

 список-параметров:<br>
    идетификатор<br>
    идентификатор , список-параметров<br><br>

 тело-функции:<br>
    список-описаний-типа оператор-функции<br><br>

 оператор-функции:<br>
    {список описаний<sub>необ</sub>     список-операторов}<br><br>

 определение данных:<br>
    extern<sub>необ</sub>  спецификатор-типа<sub>необ</sub>    список-инициализируемых-описателей<sub>необ</sub>    ;<br>
    static<sub>необ</sub>  спецификатор-типа<sub>необ</sub>     список-инициализируемых-описателей
</i>

<a name=265>
<h3>     26.5. Препроцессор</h3>
<i>
 #define идентификатор строка-лексем<br>
 #define<br>
 #define идентификатор(идентификатор,...,идентификатор)стр<br>
 #undef идентификатор<br>
 #include "имя-файла"<br>
 #include &lt;имя-файла&gt;<br>
 #if константное-выражение<br>
 #ifdef идентификатор<br>
 #ifndef идентификатор<br>
 #else<br>
 #endif<br>
 #line константа идентификатор</i>
 
<p>      Последние изменения языка C (15 ноября 1978 г.)
 
<a name=27>
<h2>     27. Присваивание структуры</h2>
<p>     Структуры могут быть присвоены, переданы функциям в качестве аргументов и возвращены функциям. Типы участвующих операндов должны оставаться теми же самыми. Другие правдоподобные операторы, такие как сравнение на равенство, не были реализованы.
<p>     В реализации возвращения структур функциями на PDP-11 имеется коварный дефект: если во время возврата происходит прерывание и та же самая функция реентерабельно вызывается во время этого прерывания, то значение возвращаемое из первого вызова, может быть испорчено. Эта трудность может возникнуть только при наличии истинного прерывания, как из операционной системы, так и из программы пользователя, прерывания, которое существенно для использования сигналов; обычные рекурсивные вызовы совершенно безопасны.

<a name=28>
<h2>     28. Тип перечисления</h2>
<p>     Введен новый тип данных, аналогичный скалярным типам языка Паскаль. К спецификатору-типа в его синтаксическом описании в разделе 8.2. Приложения А следует добавить спецификатор-перечисления с синтаксисом
<br><br><i>
 спецификатор-перечисления:<br>
 enum список-перечисления<br>
 enum идентификатор  список-перечисления<br>
 enum идентификатор<br><br>

 cписок-перечисления:<br>
 перечисляемое<br>
 список-перечисления, перечисляемое<br><br>

 перечисляемое:<br>
   идентификатор<br>
  идентификатор = константное выражение</i>
<p>     Роль идентификатора в спецификаторе-перечисления полностью аналогична роли ярлыка структуры в спецификаторе-структуры; идентификатор обозначает определенное перечисление. Например, описание
<pre> 
  enum color {RED, WHITE, BLACK, BLUE };
  . . .
  enum color *cp, col;
</pre> 
 
Объявляет идентификатор color ярлыком перечисления типа, описывающего различные цвета и затем объявляет cp указателем на объект этого типа, а col - объектом этого типа.
<p>     Идентификаторы в списке-перечисления описываются как константы и могут появиться там, где требуются (по контексту) константы. Если не используется вторая форма перечисляемого (с равенством =), то величины констант начинаются с 0 и возрастают на 1 в соответствии с прочтением их описания слева на право. Перечисляемое с присвоением = придает соответствующему идентификатору указанную величину; последующие идентификаторы продолжают прогрессию от приписанной величины.
<p>     Все ярлыки перечисления и константы могут быть различными и непохожими на ярлыки и члены структур даже при условии использования одного и того же множества идентификаторов.
<p>     Объекты данного типа перечисления рассматриваются как объекты, имеющие тип, отличный от любых типов и контролирующая программа lint сообщает об ошибках несоответствия типов. В реализации на PDP-11 со всеми перечисляемыми переменными оперируют так, как если бы они имели тип int.
<p><hr>
<table cellpadding=10>
<tr><td><a href=../../index.htm>Каталог</a></td><td><a href=../index.htm>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=c_8.htm >Назад</a></td><td><a href=index.htm#index>Оглавление</a></td></tr>
</table>
</p>
<hr>
</body>
</html>